<link rel="import" href="../../polymer-siren-mixins/entity-store.html">
<link rel="import" href="../../polymer-siren-mixins/siren-parser.html">

<script>
	(function() {
		const CompletionStore = {

			_store: new Map(),
			_listeners: new Map(),

			_initContainer(map, entityId, token, init) {
				if (!map.has(token)) {
					map.set(token, new Map());
				}
				var entityMap = map.get(token);
				if (init && !entityMap.has(entityId)) {
					entityMap.set(entityId, init);
				}
				return entityMap.get(entityId);
			},

			addListener: function(entityId, token, listener) {
				if (!entityId || typeof token !== 'string' || typeof listener !== 'function') {
					return;
				}
				this._initContainer(this._listeners, entityId, token, new Set()).add(listener);
				this._initContainer(this._store, entityId, token);
				this._fetch(entityId, token);

				//if we've already got something calculated, let the caller which
				//just attached to listen know immediately vs on next change;
				const item = this._store.get(token).get(entityId);
				if (item && item.status) {
					listener(item.status);
				}
			},

			removeListener: function(entityId, token, listener) {
				if (!entityId || typeof token !== 'string' || typeof listener !== 'function' || !this._listeners) {
					return;
				}
				this._initContainer(this._listeners, entityId, token, new Set()).delete(listener);
			},

			_fetch(entityId, token) {
				const collection = this._store.get(token);
				const item = collection.get(entityId);
				const self = this;
				if (!item) {
					const state = window.D2L.Polymer.Mixins.EntityStore.fetch(entityId, token);
					window.D2L.Polymer.Mixins.EntityStore.addListener(entityId, token, function(updatedEntity) {
						self._entityChanged(entityId, token, updatedEntity);
					});
					this._entityChanged(entityId, token, state.entity);
				}
			},
			_candidateRegex: new RegExp('sequence-description|sequenced-activity'),
			_entityChanged(entityId, token, rawEntity) {
				const collection = this._store.get(token);
				const item = collection.get(entityId);
				const entity = rawEntity && window.D2L.Hypermedia.Siren.Parse(rawEntity) || undefined;
				if (!item) {
					collection.set(entityId, {
						entity: entity
					});
				} else {
					item.entity = entity;
					collection.set(entityId, item);
				}

				if (entity) {
					//walk down into entities
					const subEntities = entity.getSubEntitiesByClass(this._candidateRegex);
					for (const sub of subEntities) {
						const self = this._getHref(sub);
						if (self) {
							this._fetch(self, token);
						}
					}

					if (this._checkForReady(token)) {
						//we've got all our entities, calculate the values
						this._countCompleted(token);
					}

				}
			},
			_checkForReady(token) {
				const collection = this._store.get(token);
				for (const item of collection.values()) {
					if (!item || typeof item.entity !== 'object') {
						return false;
					}
				}
				return true;
			},
			_getHref(entity) {
				return entity && entity.getLinkByRel && entity.getLinkByRel('self').href || entity.href;
			},

			_isModule(entity) {
				return entity.hasClass('sequence-description');
			},

			_isActivity(entity) {
				return entity.hasClass('sequenced-activity');
			},

			_isOptionalActivity(entity) {
				var isActivity = this._isActivity(entity);
				var aboutSubEntity =  entity.getSubEntityByRel('about');
				if( isActivity && aboutSubEntity && aboutSubEntity.getSubEntityByClass('completion')) {
					return false;
				} else {
					return true;
				}
			},

			_countCompleted(token) {
				let root;

				for (const item of this._store.get(token).values()) {
					const link = item.entity.getLinkByRel('https://api.brightspace.com/rels/organization');
					if (link && link.href !== undefined) {
						root = item.entity;
						break;
					}
				};
				if (root) {
					this._countCompletedActivities(token, root);
				}
			},

			_countCompletedActivities(token, entity) {
				const result = {
					completed: 0,
					optionalViewed: 0,
					optionalTotal: 0,
					total: 0
				};
				const subEntities = entity.getSubEntitiesByClass(this._candidateRegex);
				for (const sub of subEntities) {
					const self = this._getHref(sub);
					const item = this._store.get(token).get(self);
					if (item && item.entity) {
						var child = item.entity;
						if (this._isActivity(child) && !this._isOptionalActivity(child) ) {
							result.total++;
							if (this._isComplete(child)) {
								result.completed++;
							}
						} else if (this._isActivity(child) && this._isOptionalActivity(child)) {
							result.optionalTotal++;
							if ( this._isOptionalViewed(child) ) {
								result.optionalViewed++;
							}
						} else if (this._isModule(child)) {
							var childCount = this._countCompletedActivities(token, child);
							result.completed += childCount.completed;
							result.optionalViewed += childCount.optionalViewed;
							result.optionalTotal +=childCount.optionalTotal;
							result.total += childCount.total;
						}
					}
				}
				const href = entity.getLinkByRel('self').href;
				this._notify(href, token, result);
				const item = this._store.get(token).get(href);
				item.status = result;
				this._store.get(token).set(href, item);
				return result;
			},

			_isComplete(activity) {
				var aboutSubEntity =  activity.getSubEntityByRel('about');
				if( aboutSubEntity && aboutSubEntity.getSubEntityByClass('completion')) {
					return aboutSubEntity.getSubEntityByClass('completion').hasClass('completed');
				} else{
					return false
				}
			},

			_isOptionalViewed(activity) {
				var aboutSubEntity =  activity.getSubEntityByRel('about');
				if( aboutSubEntity && aboutSubEntity.getSubEntityByClass('last-viewed') ) {
					return true;
				} else{
					return false
				}
			},

			_notify: function(entityId, token, result) {
				const listenerSet = this._initContainer(this._listeners, entityId, token, new Set());
				for (const listener of listenerSet) {
					listener(result);
				}
			}
		};
		window.D2L = window.D2L || {};
		window.D2L.Polymer = window.D2L.Polymer || {};
		window.D2L.Polymer.Mixins = window.D2L.Polymer.Mixins || {};
		window.D2L.Polymer.Mixins.CompletionStore = CompletionStore;
	})();
</script>
